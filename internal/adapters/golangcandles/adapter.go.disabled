// This adapter is temporarily disabled due to compatibility issues
// TODO: Fix golangcandles adapter implementation
package golangcandles

import (
	"fmt"
	"time"

	"github.com/complimenti/golangcandles"
	"github.com/suenot/trades-to-candles-benchmark-go/internal/models"
)

// Adapter implements TradeAggregator interface for golangcandles library
type Adapter struct {
	timeframe time.Duration
	candles   *golangcandles.CandleSet
}

// NewAdapter creates a new adapter instance
func NewAdapter(timeframe time.Duration) (*Adapter, error) {
	if timeframe < time.Minute {
		return nil, fmt.Errorf("timeframe must be at least 1 minute")
	}

	return &Adapter{
		timeframe: timeframe,
		candles:   golangcandles.NewCandleSet(),
	}, nil
}

// AddTrade adds a single trade to the aggregator
func (a *Adapter) AddTrade(trade *models.Trade) error {
	if err := trade.Validate(); err != nil {
		return fmt.Errorf("invalid trade: %w", err)
	}

	// Convert our trade to library's format
	a.candles.AddTrade(golangcandles.Trade{
		Time:   trade.Timestamp,
		Price:  trade.Price,
		Volume: trade.Amount,
	}, a.timeframe)

	return nil
}

// GetCandles returns the current candles
func (a *Adapter) GetCandles() ([]*models.Candle, error) {
	libCandles := a.candles.GetCandles()
	candles := make([]*models.Candle, len(libCandles))

	for i, lc := range libCandles {
		candle := &models.Candle{
			Timestamp: lc.Time,
			Open:      lc.Open,
			High:      lc.High,
			Low:       lc.Low,
			Close:     lc.Close,
			Volume:    lc.Volume,
		}

		if err := candle.Validate(); err != nil {
			return nil, fmt.Errorf("invalid candle generated: %w", err)
		}

		candles[i] = candle
	}

	return candles, nil
}
